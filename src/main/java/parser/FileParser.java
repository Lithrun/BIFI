package parser;

import org.apache.commons.beanutils.PropertyUtils;
import parser.parsers.*;

import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.lang.reflect.Array;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.ParameterizedType;
import java.util.HashMap;
import java.util.Map;

public class FileParser<T>
{
    private T _model;

    //Can be generated by reflection, but meh
    private Class<?>[] _parsers = new Class[]
    {
        CompanyParser.class,
        InvoiceInformationLineParser.class,
        InvoiceLineParser.class,
        TextLineParser.class,
        CustomerParser.class,
    };

    public FileParser(T model)
    {
        _model = model;
    }

    /**
     * Parse the object to a string
     * @return A string that represents the IEF file
     */
    public String Parse() 
    {
        var builder = new FileBuilder();
        Parse(builder, _model);
        return builder.Build();
    }

    /**
     * Get the parse for the type and will do the same for the children
     * @param builder The file builder which lines can be appended to
     * @param model The data
     * @param <MT> Current object type
     */
    private <MT> void Parse(FileBuilder builder, MT model)
    {
        var modelClass = model.getClass();
        var parser = GetParser(modelClass);
        if (parser == null)
        {
            return;
        }
        
        parser.Parse(builder, model);
        builder.NextLine();
        
        var properties = GetProperties(modelClass);
        
        for( var property : properties)
        {
            var type = property.getPropertyType();
            
            //if array, we want to do the same for every item
            if(type.isArray())
            {
                var value = GetValue(model, property.getName());
                if (value == null)
                {
                    continue;
                }
                
                for (var i = 0; i < Array.getLength(value); i++)
                {
                    var arrayValue = Array.get(value, i);
                    if (arrayValue == null)
                    {
                        continue;
                    }
                    
                    Parse(builder, arrayValue);
                }
                
            }
            //If its a class we try get a parser also
            else if (type.getClassLoader() != null)
            {
                var value = GetValue(model, property.getName());
                if (value == null)
                {
                    continue;
                }
                
                Parse(builder, value); 
            }
        }
    }

    /**
     *  Try get value
     * @param model The current model object
     * @param name The name of the property
     * @return Null if not found
     */
    private Object GetValue(Object model, String name)
    {
        try
        {
            return PropertyUtils.getProperty(model, name);
        }
        catch (IllegalAccessException e)
        {
            e.printStackTrace();
        }
        catch (InvocationTargetException e)
        {
            e.printStackTrace();
        }
        catch (NoSuchMethodException e)
        {
            e.printStackTrace();
        }
        
        return null;
    }

    //Can be made static or can be done by static constructors or something
    private Map<Class<?>, Class<?>> _parserCache = new HashMap<>();

    /**
     * Try get parse from the parser list that implements the generic method of type
     * @param model The type of the generic model
     * @return Null if not found
     */
    private IParser GetParser(Class<?> model)
    {
        if (_parserCache.containsKey(model))
        {
            return TryCreateParser(_parserCache.get(model));
        }
        
        for (var parser : _parsers)
        {
            var interfaces = parser.getGenericInterfaces();
            
            for (var generic : interfaces)
            {
                var types = ((ParameterizedType)generic).getActualTypeArguments();
                for ( var type : types)
                {
                    if (type != model)
                    {
                        continue;
                    }
                    
                    var instance = TryCreateParser(parser);
                    if (instance == null)
                    {
                        return null;
                    }
                    
                    //cache the parser type so we have to do less when repeated
                    _parserCache.put(model, parser);
                    return instance;
                }
            }
        }
        
        return null;
    }

    /***
     * Try create a parser else return null
     * @param parser
     * @return
     */
    private IParser TryCreateParser(Class<?> parser)
    {
        try
        {
            //obsolete but it will do
            return (IParser) parser.newInstance();
        }
        catch (InstantiationException e)
        {
            return null;
        }
        catch (IllegalAccessException e)
        {
            return null;
        }
        
    }

    /**
     * Get all the getters of an object
     * @param type The object type
     */
    private PropertyDescriptor[] GetProperties(Class<?> type) 
    {
        try
        {
            return Introspector.getBeanInfo(type).getPropertyDescriptors();
        }
        catch (IntrospectionException e)
        {
            e.printStackTrace();
            return new PropertyDescriptor[0];
        }
    }
}
